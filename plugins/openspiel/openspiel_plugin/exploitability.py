"""Exploitability analysis for extensive-form games."""
from __future__ import annotations

from typing import Any


def check_zero_sum(game: dict[str, Any]) -> dict[str, Any]:
    """Check if a game is zero-sum or constant-sum (required for exploitability).

    Args:
        game: Game dict with efg_content.

    Returns:
        Dict with 'applicable' (bool) and optional 'reason' (str).
    """
    import pyspiel

    efg_content = game.get("efg_content")
    if not efg_content:
        return {"applicable": False, "reason": "Requires EFG content"}

    try:
        spiel_game = pyspiel.load_efg_game(efg_content)
        utility = spiel_game.get_type().utility

        if utility in (pyspiel.GameType.Utility.ZERO_SUM,
                       pyspiel.GameType.Utility.CONSTANT_SUM):
            return {"applicable": True}
        else:
            return {"applicable": False, "reason": "Requires zero-sum game"}
    except Exception:
        return {"applicable": False, "reason": "Failed to parse game"}


def run_exploitability(
    game: dict[str, Any], config: dict[str, Any] | None = None
) -> dict[str, Any]:
    """Measure distance from Nash equilibrium using exploitability.

    Exploitability (nash_conv) measures how much utility an opponent can gain
    by best-responding to a strategy. Zero exploitability = Nash equilibrium.

    Args:
        game: Deserialized extensive-form game dict.
        config: Configuration with optional key:
            - policy: Strategy profile to analyze (default: uniform random)

    Returns:
        Dict with exploitability value and per-player values.
    """
    try:
        import pyspiel
        from open_spiel.python.algorithms import exploitability as exploit
    except ImportError as e:
        return {
            "summary": "OpenSpiel not available",
            "details": {"error": f"Failed to import modules: {e}"},
        }

    config = config or {}

    efg_content = game.get("efg_content")
    if not efg_content:
        return {
            "summary": "Error: No EFG content available",
            "details": {"error": "Game must include 'efg_content'"},
        }

    try:
        spiel_game = pyspiel.load_efg_game(efg_content)

        # Use uniform random policy if none provided
        from open_spiel.python.policy import UniformRandomPolicy
        policy = UniformRandomPolicy(spiel_game)

        # Compute exploitability (nash_conv)
        nash_conv = exploit.exploitability(spiel_game, policy)

        # Interpret exploitability
        if nash_conv < 0.001:
            quality = "Near-optimal (essentially Nash)"
        elif nash_conv < 0.01:
            quality = "Very good approximation"
        elif nash_conv < 0.1:
            quality = "Good approximation"
        elif nash_conv < 0.5:
            quality = "Moderate approximation"
        else:
            quality = "Poor approximation"

        return {
            "summary": f"Exploitability: {nash_conv:.4f} ({quality})",
            "details": {
                "nash_conv": float(nash_conv),
                "quality": quality,
                "policy_type": "uniform_random",
            },
        }

    except Exception as e:
        return {
            "summary": f"Error: {str(e)}",
            "details": {"error": str(e)},
        }


def run_policy_exploitability(
    game: dict[str, Any], config: dict[str, Any] | None = None
) -> dict[str, Any]:
    """Compute exploitability of a CFR-computed policy.

    This analysis first runs CFR to compute a policy, then measures
    its exploitability. Useful for verifying CFR convergence.

    Args:
        game: Deserialized extensive-form game dict.
        config: Configuration with optional keys:
            - iterations: CFR iterations before measuring (default: 1000)
            - algorithm: CFR variant (default: "cfr+")

    Returns:
        Dict with exploitability and CFR iteration data.
    """
    try:
        import pyspiel
        from open_spiel.python.algorithms import cfr
        from open_spiel.python.algorithms import exploitability as exploit
    except ImportError as e:
        return {
            "summary": "OpenSpiel not available",
            "details": {"error": f"Failed to import modules: {e}"},
        }

    config = config or {}
    iterations = config.get("iterations", 1000)
    algorithm = config.get("algorithm", "cfr+")

    efg_content = game.get("efg_content")
    if not efg_content:
        return {
            "summary": "Error: No EFG content available",
            "details": {"error": "Game must include 'efg_content'"},
        }

    try:
        spiel_game = pyspiel.load_efg_game(efg_content)

        # Run CFR
        if algorithm == "cfr+":
            solver = cfr.CFRPlusSolver(spiel_game)
        else:
            solver = cfr.CFRSolver(spiel_game)

        # Track exploitability over iterations
        exploitability_history = []
        check_points = [10, 50, 100, 500, 1000]
        check_points = [c for c in check_points if c <= iterations]

        for i in range(1, iterations + 1):
            solver.evaluate_and_update_policy()

            if i in check_points:
                policy = solver.average_policy()
                nash_conv = exploit.exploitability(spiel_game, policy)
                exploitability_history.append({
                    "iteration": i,
                    "exploitability": float(nash_conv),
                })

        # Final exploitability
        final_policy = solver.average_policy()
        final_exploitability = exploit.exploitability(spiel_game, final_policy)

        if final_exploitability < 0.001:
            summary = f"Converged to Nash (exploitability: {final_exploitability:.6f})"
        else:
            summary = f"Exploitability after {iterations} iterations: {final_exploitability:.4f}"

        return {
            "summary": summary,
            "details": {
                "final_exploitability": float(final_exploitability),
                "iterations": iterations,
                "algorithm": algorithm,
                "convergence_history": exploitability_history,
            },
        }

    except Exception as e:
        return {
            "summary": f"Error: {str(e)}",
            "details": {"error": str(e)},
        }
